\documentclass[11pt,t,xcolor=pdftex,svgnames]{beamer}
\mode<presentation> {\usetheme{NIST}}

\usepackage{colortbl}
\usepackage{multirow}

\title{Ramstake}
\subtitle{Submission by Alan Szepieniec, KU Leuven}
\author{Jacob Alperin-Sheriff}
\institute{NIST}

\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}


\usepackage{environ}% Required for \NewEnviron, i.e. to read the whole body of the environment
\makeatletter

\newcounter{acolumn}%  Number of current column
\newlength{\acolumnmaxheight}%   Maximum column height


% `column` replacement to measure height
\newenvironment{@acolumn}[1]{%
    \stepcounter{acolumn}%
    \begin{lrbox}{\@tempboxa}%
    \begin{minipage}{#1}%
}{%
    \end{minipage}
    \end{lrbox}
    \@tempdimc=\dimexpr\ht\@tempboxa+\dp\@tempboxa\relax
    % Save height of this column:
    \expandafter\xdef\csname acolumn@height@\roman{acolumn}\endcsname{\the\@tempdimc}%
    % Save maximum height
    \ifdim\@tempdimc>\acolumnmaxheight
        \global\acolumnmaxheight=\@tempdimc
    \fi
}

% `column` wrapper which sets the height beforehand
\newenvironment{@@acolumn}[1]{%
    \stepcounter{acolumn}%
    % The \autoheight macro contains a \vspace macro with the maximum height minus the natural column height
    \edef\autoheight{\noexpand\vspace*{\dimexpr\acolumnmaxheight-\csname acolumn@height@\roman{acolumn}\endcsname\relax}}%
    % Call original `column`:
    \orig@column{#1}%
}{%
    \endorig@column
}

% Save orignal `column` environment away
\let\orig@column\column
\let\endorig@column\endcolumn

% `columns` variant with automatic height adjustment
\NewEnviron{acolumns}[1][]{%
    % Init vars:
    \setcounter{acolumn}{0}%
    \setlength{\acolumnmaxheight}{0pt}%
    \def\autoheight{\vspace*{0pt}}%
    % Set `column` environment to special measuring environment
    \let\column\@acolumn
    \let\endcolumn\end@acolumn
    \BODY% measure heights
    % Reset counter for second processing round
    \setcounter{acolumn}{0}%
    % Set `column` environment to wrapper
    \let\column\@@acolumn
    \let\endcolumn\end@@acolumn
    % Finally process columns now for real
    \begin{columns}[#1]%
        \BODY
    \end{columns}%
}
\makeatother

\newcommand{\Red}[1]{{\color{Red}#1}}
\newcommand{\xof}{\ensuremath{\text{xof}}}

\input{beamhead}
\input{../head}

\begin{document}

%title page
    \setbeamertemplate{headline}[title_page]
    \setbeamertemplate{footline}[title_page]
    \csname beamer@calculateheadfoot\endcsname %recalculate head and foot dimension
        \begin{frame}
            \titlepage
        \end{frame}
%head and foot for body text    
    \setbeamertemplate{headline}[body]
    \setbeamertemplate{footline}[body]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}{Outline}
%     \vskip 5mm
%     {\parbox{.95\textwidth}{\tableofcontents[hideallsubsections]}}
% \end{frame}

%\begin{frame}
%    \titlepage
%\end{frame}
%
%\begin{frame}
%    \frametitle{Overview}
%
%    %\tableofcontents
%    \begin{itemize}
%        \item Scope of the project
%        \item Bayesian language models
%        \item Results
%        \item Research plan
%        \item Side projects
%        \item Reflections
%        \item Formalities
%    \end{itemize}
%
%\end{frame}
\section{Basic Idea}

\begin{frame}    
    \frametitle{Another Variation on Learning With Errors}

    \onslide<1->
    \begin{block}{(Ring)-LWE reminder}
        \begin{description}
            \item[KeyGen$(1^{\lambda})$:]
\begin{itemize}
\item Sample uniform $a \gets R$, \alert{short} (Euclidean norm)
              $\Red{s},\Red{e}$. 
\item Output $(a,b=\Red{s}\cdot a +
              \Red{e})$
\end{itemize}
            \item[Enc$(\mu)$:] 
\begin{itemize}
  \item Sample \alert{short} (Euclidean norm)
              $\Red{r},\Red{e_1}, \Red{e_2}$.
            \item Output  
              $c=(a\cdot \Red{r}+\Red{e_1}, b\cdot
              \Red{r}+\Red{e_2}+(q/2)\mu)$
\end{itemize}
             \item[Dec$(c)$:] Compute $u=c_1\Red{s}-c_2$, recover
               $\mu$ from $u$
        \end{description}
    \end{block}

    \onslide<2->
    \begin{block}{What if Ring is the Integers?}
        \begin{itemize}
          \item Modulus clearly needs be $q=2^{\Omega(\text{poly}(n))}$ to avoid
          trivial brute-force
            \item[\RedCross]  Easy to break with LLL if \alert{short} =
              Euclidean norms
            \item Alternative: \alert{short} = Hamming weight in binary
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}    
    \frametitle{Binary Hamming Weights}
\begin{itemize}
\item<.-> Hamming weight $\wt(\vecv)$is number of non-zero
  elements
\smallskip
\item<.-> View integer $v$ in $\Z$ as an (infinite length) bit-vector
\smallskip
\item<+-> $\wt(v + w) \leq \wt(v)+\wt(w)$.
\smallskip
\item<.-> $\wt(v \cdot w ) \leq \wt(v) \cdot \wt(w)$
\end{itemize}
\onslide<+->
\begin{block}{(Tight) Example}
\begin{table}
\begin{tabular}{cr|cccc}
&3&&&1&1\\
$\cdot$&5&&1&0&1\\
\hline
&15&1&1&1&1\\
\end{tabular}
\end{table}
\end{block}
\begin{itemize}
\item<+-> Important: $\wt(v \cdot w ) \leq \wt(v) \cdot
  \wt(w)$ holds \alert{over the integers}
\end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Mersenne Primes}
\begin{itemize}
\item<+-> Does $\wt(v \cdot w) \leq \wt(v) \cdot \wt(w)$ hold modulo $q$?
\item<+->[\RedCross] For most $q$, no!
\item<+-> Example: $q=2^{n}+1$
\begin{itemize}
\item<.-> $\wt(2 \bmod{q})$ = 1
\item<.-> $\wt(2^{n} \bmod{q})$ = 1
\item<.->[\RedCross] $\wt((2\cdot 2^{n}) = 2^{n}-1 \bmod{q})=n$ 
\end{itemize}
\end{itemize} 
\onslide<+->
\begin{block}{Mersenne Numbers}
\begin{itemize}
\item<.->[\GreenCheck] $\wt$ relations do hold modulo $q=2^{n}-1$. 
\item<+-> Reason: rep. of $2^{k}$ mod $q$  in $[0,2^{n}-1)$ is always
$2^{\ell}$
\item<.-> $v$ mod $q$ = summing $\wt(v)$ different $\wt(1)$
  numbers mod $q$
\item<+->  $q$ needs to be a \alert{Mersenne Prime} to avoid
  decomposition attacks.
\item[\RedCross]<.-> For desired parameters, Ramstake limited to $n=216091,756839$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}\frametitle{Ramstake Description -- KeyGen}
\onslide<+->
On input randommess $seed$
\begin{enumerate}
\item<+-> Expand $seed$ into necessary randomness via $\vecr \gets
  \xof(seed)$
\begin{itemize}
\smallskip
\item<.-> Reason for $\text{xof}$: to
  shorten keys (a la Kyber/NewHope/Frodo)
\smallskip
\end{itemize}
\item<+-> Sample random $seed\_a$ (via $\vecr$)
\medskip
\item<+-> Choose $a \gets \Z_q$ randomly via $\text{xof}(seed\_a)$ 
\medskip
\item<+-> Choose \alert{low-weight} $s, e \in \Z_q$ (via $\vecr$)
\medskip
\item<+-> Compute $b = s\cdot a + e \bmod{q}$. 
\medskip
\item<+-> Secret key is $sk=(s, seed)$, public key is $pk=(seed\_a, b)$
\end{enumerate}
\end{frame}

\begin{frame}\frametitle{Ramstake Description -- Encapsulation}
\onslide<+->
On input $pk=(seed\_a,b)$, message $\mu$
\begin{enumerate}
\item<+-> Compute $r=xof(\mu)$.
\begin{itemize}
\item<.-> $r$ will be used both to sample 
\medskip
\item<.-> Reason for $\text{xof}$: to
  shorten public key (a la Kyber/NewHope/Frodo)
\end{itemize}
\medskip
\item<+-> Choose \alert{low-weight} $s, e \in \Z_q$
\medskip
\item<+-> Compute $b = s\cdot a + e \bmod{q}$. 
\medskip
\item<+-> Secret key is $(s)$, public key is $(seed\_a, b)$
\end{enumerate}
\end{frame}

\begin{frame}\frametitle{Parameter Sizes}
moo
\end{frame}

\begin{frame}\frametitle{Attacks (Part 1)}
moo
\end{frame}


\end{document}
