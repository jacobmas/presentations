\section{Preliminaries}
\label{sec:preliminaries}
We denote the real numbers by $\R$ and the integers by $\Z$. For a
positive integer $d$, we use $[d]$ to denote the set $\{1, \ldots,
d\}$. We denote vectors over $\R$ and $\Z$ with lower-case bold
letters (e.g. $\vecx$), and matrices by upper-case bold letters
(e.g. $\matA$). We say that a function is \emph{negligible}, written
$\negl(n)$, if it vanishes faster than the inverse of any polynomial
in $n$.  The \emph{statistical distance} between two distributions
$X$, $Y$ over a finite or countable set $D$ is
$\Delta(X,Y)=\frac{1}{2}\sum_{w\in D}|X(w)-Y(w)|$. Statistical
distance is a metric, and in particular obeys the triangle inequality.
Let $\set{X_{n}}$ and $\set{Y_{n}}$ be ensembles of random variables
indexed by the security parameter $n$. We say that $X$ and $Y$ are
\emph{statistically close} if $\Delta(X_{n},Y_{n}) = \negl(n)$.  For a
matrix $\matX \in \mathbb{R}^{n \times k}$, the \emph{largest singular
  value} (also known as the \emph{spectral norm}) of $\matX$ is
defined as $s_1(\matX) = \max_{\length{\vecu}=1}\length{\matX \vecu}$.

\subsection{Lattices and Gaussians}
\label{subsec:gaussians_lattices}

A (full-rank) $m$-dimensional \emph{integer lattice} $\Lambda$ is an
additive subgroup of $\Z^m$ with finite index.
%  The dual lattice of
% $\Lambda$, denoted $\Lambda^*$, is defined as $\Lambda^*=\{\vecx \in
% \R^m: \forall\; \vecv \in \Lambda, \inner{\vecx, \vecv} \in \Z\}$.
This work is concerned with the family of integer lattices whose
cryptographic importance was first demonstrated by
Ajtai~\cite{ajtai04:_gener_hard_instan_lattic_probl}. For integers $n
\geq 1$, modulus $q \geq 2$, an $m$-dimensional lattice from this
family is specified by an ``arity check'' matrix $\matA \in \Zq^{n
  \times m}$:
\[\Lambda^{\perp}(\matA) = \set{ \vecx \in \Z^m: \matA\vecx = \veczero
  \in \Zq^{n} } \subseteq \Z^m.\] For any $\vecy$ in the subgroup of
$\Zq^{n}$ generated by the columns of $\matA$, we also define the
coset
\[\Lambda_{\vecy}^{\perp}(\matA) = \set{ \vecx \in \Z^m: \matA\vecx =
  \vecy \bmod q} = \Lambda^{\perp}(\matA)+\bar{\vecx},\] where
$\bar{\vecx} \in \Z^m$ is an arbitrary solution to
$\matA\bar{\vecx}=\vecy$.

We briefly recall Gaussian distributions over lattices (for more
details see
\cite{DBLP:journals/siamcomp/MicciancioR07,DBLP:conf/stoc/GentryPV08}). For
$s > 0$ and dimension $m \geq 1$, the Gaussian function $\rho_{s}:
\R^m \to (0,1]$ is defined as $\rho_s(\vecx) =
\exp(-\pi\length{\vecx}^2/s^2)$. For a coset $\Lambda+\vecc$ of a
lattice $\Lambda$, the \emph{discrete Gaussian distribution}
$D_{\Lambda+\vecc, s}$ (centered at zero) assigns probability
proportional to $\rho_s(\vecx)$ to each vector in the coset, and
probability zero elsewhere.

We will need a few standard concepts and facts about discrete
Gaussians over lattices.  First, for $\epsilon > 0$ the
\emph{smoothing
  parameter}~\cite{DBLP:journals/siamcomp/MicciancioR07}
$\eta_{\epsilon}(\Lambda)$ of an $n$-dimensional lattice is a positive
real value.  We will not need its precise definition, which depends on
the notion of the \emph{dual} lattice, but only recall the few
relevant facts that we need; for details, see,
e.g.,~\cite{DBLP:journals/siamcomp/MicciancioR07,DBLP:conf/stoc/GentryPV08,DBLP:conf/eurocrypt/MicciancioP12}.

\jnote{Fixed a typo; in last part of this was $\matR \gets D_{\Z,r}^{m \times k}$,
changed $m$ to $n$ [this is how it is in MP12 and also it wouldn't make sense 
with an $m$ one place and $n$ in the other}
\begin{lemma}
  \label{Gaussianlemmas}
  Let $m \geq C n \lg q$ for some constant $C >1$.
  \begin{enumerate}
  \item For any $\wsln$ function, we have $\eta_{\epsilon}(\Z^n)\leq
    \wsln$ for some negligible $\epsilon(n)=\negl(n)$.
  \item With all but $\negl(n)$ probability over the uniformly random
    choice of $\matA \in \Zq^{n \times m}$, the following holds: For
    $\vece \gets D_{\Z^m, r}$ where $r=\wsln$, the distribution of
    $\vecy=\matA\vece \bmod q$ is within $\negl(n)$ statistical
    distance of uniform, and the conditional distribution of $\vece$
    given $\vecy$ is $D_{\Lambda_{\vecy}^{\perp}(\matA), r}$.
  \item For any $m$-dimensional lattice $\Lambda$, any $\vecc \in
    \Z^{m}$, and any $r \geq \smootheps(\Lambda)$ where
    $\epsilon(n)=\negl(n)$, we have $\length{D_{\Lambda+\vecc,r}} \leq
    r \sqrt{m}$ with all but $\negl(n)$ probability.  In addition, for
    $\Lambda=\Z$ we have $\abs{D_{\Z,r}} \leq r \cdot \wsln$ except
    with $\negl(n)$ probability.
  \item For any $r > 0$, and for $\matR \gets D_{\Z,r}^{n \times k}$,
    we have $s_{1}(\matR) \leq r \cdot O(\sqrt{n}+\sqrt{k})$ except
    with $\negl(n)$ probability.
  \end{enumerate}
\end{lemma}

\begin{lemma}%[{\cite[Lemma 3]{DBLP:conf/tcc/DodisGKPV10}}]
  \label{sumplusgaussian}
  For any real number $r = \omega(\sqrt{\log{n}})$ and $c \in \Z$, the
  statistical distance between $D_{\Z, r}$ and $c+D_{\Z, r}$ is
  $O(\abs{c}/r)$.
\end{lemma}

\subsection{Trapdoors for Lattices}
\label{subsec:trapdoors}

We recall the efficient trapdoor construction and associated sampling
algorithm of Micciancio and
Peikert~\cite{DBLP:conf/eurocrypt/MicciancioP12}. This construction uses
a universal public ``gadget'' matrix $\matG \in \Zq^{n \times w}$ for
which there is an efficient discrete Gaussian sampling algorithm for
any parameter $r \geq \omega(\sqrt{\log{n}}) \geq
\smootheps(\lamperp(\matG))$ (for some $\epsilon(n)=\negl(n)$), i.e.,
an algorithm that, given any $\vecy \in \Zq^{n}$ and $r$, outputs a
sample from $D_{\lamperp_{\vecy}(\matG),r}$.  For concreteness, as
in~\cite{DBLP:conf/eurocrypt/MicciancioP12} we take $\matG = \matI_{n}
\otimes [1, 2, 4, \ldots, 2^{k-1}] \in \Zq^{n \times nk}$ for $k =
\ceil{\lg q}$.

Following~\cite{DBLP:conf/eurocrypt/MicciancioP12}, we say that an
integer matrix $\matR \in \Z^{(m-n) \times w}$ is a ``strong''
trapdoor with tag $H$ for $\matA \in \Zq^{n \times m}$ if $\matA
\left[ \begin{smallmatrix} \matR \\ \matI
  \end{smallmatrix} \right] = H(\matG)$ for some efficiently
computable and invertible linear transformation $H$ over~$\Zq^{n}$,
which is applied column-wise to $\matG$.  Equivalently, in place of
$H(\matG)$ we may write $\matH \cdot \matG$ for some invertible matrix
$\matH \in \Zq^{n \times n}$, but in our constructions it will be more
natural to work with invertible linear transformations, without
explicitly referring to the matrices that represent them.

\begin{lemma}[{\cite[Theorem 5.1]{DBLP:conf/eurocrypt/MicciancioP12}}]
  \label{lem:trapgen-sample}
  Let $\matR$ be a strong trapdoor for $\matA \in \Zq^{n \times m}$.
  There is an efficient randomized algorithm that, given $\matR$, any
  $\vecu \in \Zq^n$, and any $r \geq s_1(\matR)\cdot
  \omega(\sqrt{\log{n}}) \geq \eta_{\epsilon}(\lamperp(\matA))$ (for
  some $\epsilon(n) = \negl(n)$), samples from a distribution within
  $\negl(n)$ distance of $D_{\Lambda_{\vecu}^{\perp}(\matA), r}$.
\end{lemma}

\subsection{Learning With Errors}
\label{subsec:LWE}

The \emph{learning with errors} (\lwe) problem is parameterized by a
dimension $n\geq 1$, an integer modulus $q \geq 2$ and an error
distribution $\chi$ over $\Z$ (or its induced distribution over
$\Zq$). For a vector $\vecs \in \Zq^n$, the distribution $A_{\vecs,
  \chi}$ over $\Zq^n \times \Zq$ is sampled by choosing $\veca \in
\Zq^n$ uniformly at random and outputting $(\veca, \inner{\veca,
  \vecs}+x)$, where $x \gets \chi$.

The search version of \lwe is to recover an arbitrary $\vecs$ given
oracle access to $A_{\vecs, \chi}$. The decision version of \lwe is to
distinguish, with non-negligible advantage, between samples from
$A_{\vecs, \chi}$ for uniformly random $\vecs \in \Zq^n$ and uniformly
random samples from $\Zq^n \times \Zq$. There are search-to-decision
reductions for $\lwe$ for a variety of moduli $q$ and parameter
conditions (\cite{DBLP:journals/jacm/Regev09,
  DBLP:conf/stoc/Peikert09,
  DBLP:conf/crypto/ApplebaumCPS09,DBLP:conf/crypto/MicciancioM11,
  DBLP:conf/eurocrypt/MicciancioP12}).  Of particular importance to us
are the reductions
from~\cite{DBLP:conf/crypto/ApplebaumCPS09,DBLP:conf/eurocrypt/MicciancioP12}
for $q=p^e$, where $p$ is prime, $e \geq 1$ is an integer, and
$\Pr_{\vecx \gets \chi}[\abs{\vecx} \geq p/2] = \negl(n)$.  The
reductions runs in time polynomial in $n$, $p$, and $e$.

For error distribution $\chi = D_{\Z, \alpha q}$, where $\alpha q \geq
2\sqrt{n}$, the search version of \lwe is at least as hard as
\emph{quantumly} approximating certain worst-case problems on
$n$-dimensional lattices to within $\Otil(n/a)$
factors~\cite{DBLP:journals/jacm/Regev09}; for certain parameters, a
classical reduction is known for a subset of these lattice
problems~\cite{DBLP:conf/stoc/Peikert09}.
% Our proofs of security
% require $1/\alpha$ to be slightly superpolynomial in $n$ and thus rely
% on the assumed hardness of these lattice problems for slightly
% superpolynomial approximation factors and runtimes.
Note that the original hardness result for search-\lwe was for a
continuous Gaussian error distribution, but this can be converted to a
discrete Gaussian disribution with a suitable randomized rounding
method~\cite{DBLP:conf/crypto/Peikert10}.

We will need the transformation of Applebaum
\etal~\cite{DBLP:conf/crypto/ApplebaumCPS09} from the standard
decision-\lwe problem (where $\vecs$ is uniform) to one where the
secret $\vecs$ is chosen from the error distribution $\chi$.

\begin{lemma}[{\cite[Lemma
    2]{DBLP:conf/crypto/ApplebaumCPS09}}] \label{LWEtransformation}
  Let $q=p^{e}$ be a prime power. There is a deterministic
  polynomial-time transformation that, for arbitrary $\vecs \in
  \Z_q^n$ and error distribution $\chi$, maps $A_{\vecs, \chi}$ to
  $A_{\bar{\vecx}, \chi}$ where $\bar{\vecx} \gets \chi^n$, and maps
  $U(\Z_q^n \times \Z_q)$ to itself. The transformation also produces
  an invertible square matrix $\bar{\matA} \in \Zq^{n \times n}$ and
  $\bar{\vecb} \in \Zq^n$ that, when mapping $A_{\vecs, \chi}$ to
  $A_{\bar{\vecx}, \chi}$, satisfy $\bar{\vecx} =
  -\bar{\matA}^{t}\vecs+\bar{\vecb}$.
\end{lemma}

\iflncs
\subsection{Key-Dependent Message Security}
\label{subsec:KDM}

In defining key-dependent message security  for
public-key encryption and for identity-based encryption, we adapt the
original definitions of Black
\etal~\cite{DBLP:conf/sacrypt/BlackRS02}. As in their definitions, the adversary 
plays a game with a challenger, and is able
to make encryption queries for functions from a certain family $\mathcal{F}$ of the 
users' secret
keys. (Technically, $\mathcal{F}$ is a family of sets of functions
parameterized by the security parameter $n$ and the number of users
$d$.)  

To simplify our security proofs, in our definition the adversary
specifies two functions $(f_0, f_1) \in \mathcal{F}$ with each query,
and must distinguish between encryptions of $f_0$ and encryptions of
$f_1$. If $f(k_1, \ldots, k_d)=0$ is contained in $\mathcal{F}$ (which
should be the case if we want KDM security to imply standard semantic
security), then this definition is at least as
strong as (and is in fact equivalent to) the original.

To define KDM-security for identity-based encryption, we extend the 
standard
definition of selective security for IBE
from~\cite{DBLP:journals/joc/CanettiHK07,
  DBLP:journals/siamcomp/BonehCHK07}. Note that we 
add a parameter $d$ to the $\ibesetup$ algorithm denoting the maximum 
number of users in a clique (i.e., a set of users such that the secret key for 
any user in the clique may be safely encrypted under the identity for any 
user in the clique).
  An adversary plays a game with a
challenger that answer encryption queries for functions of the secret
keys for identities from a list $\mathcal{I}$, encrypted under
identities from $\mathcal{I}$. For selective security, $\mathcal{I}$
must be specified before the adversary sees the public key and remains
static throughout the game. In addition to (key-dependent) encryption
queries, the adversary is also allowed to make extraction queries for
any identity $id \notin \mathcal{I}$.

\else
\subsection{Identity-Based Encryption}

As usual, an identity-based encryption
scheme~\cite{DBLP:journals/siamcomp/BonehF03} consists of four
algorithms: $\ibesetup, \ibeext, \ibeenc, \ibedec$. In our scheme, in
addition to the security parameter $1^n$, $\ibesetup$ also takes in a
parameter $d$ denoting the maximum number of users in a clique
. $\ibesetup$ outputs the master public key $\MPK$ (which
includes the system parameters) and the master secret key
$\MSK$. $\ibeext$ takes in an identity $id$ $\MPK$, $\MSK$ and outputs
a secret key $\algo{SK}_{id}$ for identity $id$. $\ibeenc$ takes in
$\MPK$, $id$ and a message $\mu$, and returns a ciphertext
$c$. $\ibedec$ takes in $\MPK, \algo{SK}_{id}$ and ciphertext $c$, and
returns message $\mu$. As usual for lattice-based schemes, correctness
requires that with overwhelming probability over the random coins used
by the algorithms, we have that for $(\MPK, \MSK)\gets
\ibesetup(1^n,d)$, $\algo{SK}_{id} \gets \ibeext(\MPK, \MSK, id)$ and
any message $\mu$: $\ibedec(\MPK, \algo{SK}_{id}, \ibeenc(\MPK, id, \mu)) = \mu.$
\subsection{Key-Dependent Message Security}
\label{subsec:KDM}

We now proceed to formally define key-dependent message security for
public-key encryption and for identity-based encryption. We adapt the
original definitions of Black
\etal~\cite{DBLP:conf/sacrypt/BlackRS02}. In their original
definitions, the adversary plays a game with a challenger, and is able
to make encryption queries for functions of the users' secret
keys. The adversary is restricted to functions from a certain family
$\mathcal{F} \subset \{f: \mathcal{K}^{\ell} \to \mathcal{M} \}$,
where $\mathcal{K}$ is the keyspace for identity secret keys and
$\mathcal{M}$ is the message space of the encryption
scheme. (Technically, $\mathcal{F}$ is a family of sets of functions
parameterized by the security parameter $n$ and the number of users
$d$.)  The adversary's goal is to distinguish between honest
encryptions of the queried function applied to the secret keys, and
encryptions of a fixed dummy value (say, $0$).

To simplify our security proofs, in our definition the adversary
specifies two functions $(f_0, f_1) \in \mathcal{F}$ with each query,
and must distinguish between encryptions of $f_0$ and encryptions of
$f_1$. If $f(k_1, \ldots, k_d)=0$ is contained in $\mathcal{F}$ (which
should be the case if we want KDM security to imply standard semantic
security), then it is easy to see that this definition is at least as
strong as (and is in fact equivalent to) the original.

To define KDM-security for identity-based encryption, we extend the
definition of selective security for IBE
from~\cite{DBLP:journals/joc/CanettiHK07,
  DBLP:journals/siamcomp/BonehCHK07}. An adversary plays a game with a
challenger that answer encryption queries for functions of the secret
keys for identities from a list $\mathcal{I}$, encrypted under
identities from $\mathcal{I}$. For selective security, $\mathcal{I}$
must be specified before the adversary sees the public key and remains
static throughout the game. In addition to (key-dependent) encryption
queries, the adversary is also allowed to make extraction queries for
any identity $id \notin \mathcal{I}$.

Our definitions can be extended to adaptive security as well. In this
case, the adversary can adaptively add identities to $\mathcal{I}$
during the course of the game. In order to make the definition
meaningful, the adversary is only allowed to add identities to
$\mathcal{I}$ for which it has not previously made an extraction
query.

\fi

For an identity-based encryption scheme $(\ibesetup, \ibeext, \ibeenc,
\ibedec)$, the security game between an adversary and a challenger is
parameterized by some $\beta \in \bit$ and proceeds as follows.
\begin{enumerate}[itemsep=0pt]
\item $\Adv(1^n, d)$ outputs a list of (distinct) target identities
  $\mathcal{I} = (id_1, id_2, \ldots id_{\ell})$ for some $\ell \leq
  d$.
\item The challenger runs $(\mpk, \msk) \gets \ibesetup(1^n, d)$. The
  adversary is given $\mpk$. The challenger then extracts secret keys
  for each of the target identities, running $sk_{i} \gets
  \ibeext_{\msk}(id_i)$ for each $i \in [\ell]$.
\item $\Adv$ then can make extraction and encryption queries, in the
  order of its choice.
  \begin{description}
  \item[Extraction Queries:] $\Adv$ can query $\ibeext_{\msk}(\cdot)$
    for any identity $id \notin \mathcal{I}$
  \item[Encryption Queries:] $\Adv$ can make encryption queries of the
    form $(f_0, f_1, i)$, where $f_0, f_1 \in \mathcal{F}$ and $1 \leq
    i \leq \ell$.  The challenger computes $m \gets f_{\beta}(sk_1,
    \ldots, sk_{\ell})$ and $c \gets \ibeenc(id_i, m)$, and returns
    $c$ to $\Adv$.
  \end{description}
\end{enumerate}
We say that the scheme is selective-identity KDM-CPA secure with
respect to $\mathcal{F}$ if the games for $\beta=0,1$ are
computationally indistinguishable.

We define KDM-CPA security for a public-key scheme
$(\pkcgen, \pkcenc, \pkcdec)$ in a similar manner. Starting at phase
two above (since there are no identities to target), the challenger
now runs $\pkcgen$ $d$ times, and gives $pk_1, \ldots, pk_d$ to the
adversary. In phase three, the adversary can only make encryption
queries (since there are no identities to extract), and requests
encryptions under public keys instead of identities. Everything else
is exactly the same.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "kdm-ibe"
%%% End: 





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "kdm-ibe"
%%% End: 
